{
    "Ex10.hs--emp": [
        "{v:Map k v | v =/= Tip}",
        "{v:Map {v:String | false} v}",
        "{v:Map k v | Empty v}",
        "{v:Map k v | Set_emp (keys v)}",
        "{v:Map k v | Empty v }",
        "{v:Map {v:k | k < x} v }",
        "{v:Map {k: k | k < key v }} v",
        "_  =",
        "_",
        "Map k v",
        "{v:Map k v | keys v = empty}",
        "{v:Map {v:k | false} v }",
        "{v:Map {v:k | false} v}",
        "{v:Map {v:k | v == k} v}",
        "{v:Map k v | Set_emp v }",
        "{v:Map k v | false}"
    ],
    "Ex10.hs--eval": [
        "_ -> {v:Expr | isSubsetOf (free v) (keys g)}",
        "Env -> _ -> _",
        "Env -> ClosedExpr Env",
        "Env -> Expr -> Expr",
        "{v:Map Var Expr | Subset (free v) (keys v)} -> Expr -> Expr",
        "_ -> _ -> _",
        "Env -> Val -> Val",
        "Map Var Expr -> ClosedExpr G -> Val",
        "_ -> _ -> {v:Expr | eval g v }",
        "Map Var Expr -> Expr -> Expr",
        "_ -> {v:Expr | val v}",
        "{v:Map Var Expr | Subset (free v) (keys v)} -> ClosedExpr {v:Expr | val v } -> Expr",
        "Env -> Expr -> Val",
        "Env -> ClosedExpr G -> Val"
    ],
    "Ex10.hs--topEval": [
        "Expr -> Expr",
        "_ -> Env -> Val",
        "{v:Expr | val v} -> {v:Expr | val v}",
        "_ -> {v:Expr | val v}",
        "Expr -> {v:Expr | val v}",
        "_ -> _",
        "Expr -> Val",
        "Map Var Expr -> Val",
        "Env -> Expr -> Val",
        "_ -> Val",
        "Map Var Expr -> Expr",
        "{v:Expr | val v}",
        "Env -> ClosedExpr G -> Val"
    ],
    "Ex10.hs--lemNotMem": [
        "_ -> _ -> Bool",
        "_ -> _ -> _",
        "k -> Map k v -> {v:Bool | not (in k (keys M))}",
        "k -> Map k v -> Bool",
        "_ -> _ -> {v:Bool | v }",
        "{v:k | v < key} -> Map k v -> {v:Bool | not (In v Ys)}",
        "k -> Map k v -> {v:Bool | not (In k v)}",
        "k -> Map k v -> Boolean",
        "_ -> _ -> TRUE",
        "k -> Map k v -> {v:Bool | v}"
    ],
    "Ex10.hs--mem": [
        "k -> v -> (k -> v -> Bool) -> Bool",
        "k -> v -> {v | mem k v}",
        "k -> {v:Expr | In k (keys v)}",
        "_ -> _ -> _",
        "{v:k | v < k} -> {v:Bool | v}",
        "k -> v -> _ -> _",
        "k -> _ -> TRUE",
        "{k:k | k < k'} -> {v:Map k v | k' `mem` v}",
        "_ -> _ -> TRUE",
        "{v:Expr | v =/= Const 0} -> {v:Expr | v =/= Const 0} -> BOOL",
        "{v:Bool | v }",
        "_ -> _ -> BOOL",
        "_ -> _ -> FALSE",
        "k -> Map k v -> TRUE"
    ],
    "Ex10.hs--get": [
        "_ -> _ -> {v:_ | v }",
        "_ -> {v:Expr | Subset (free v) (keys m)}",
        "_ -> _ -> _",
        "_ -> Map Var _ -> _",
        "_ -> (Map k v) -> _",
        "_ -> Map {v:k | v < key} v -> v",
        "{v:Val | val v} -> g:Map Var Expr -> v",
        "_ -> {v:Val | Subset (free v) (keys g)} -> Val",
        "k -> Map k v -> v",
        "{v:Expr | lemNotMem v (keys g)} -> {v:Expr | Subset (free v) (keys g)} -> v"
    ],
    "Ex10.hs--set": [
        "_ -> _ -> _ -> _",
        "k -> v -> Map k v -> Map k v",
        "_ -> _ -> _",
        "_ -> _ -> _ -> _ -> _",
        "_ -> _ -> _ -> {v:Expr | v =/= Const 0}",
        "k -> v -> Map {v:k | k} v -> Map {v:k | k} v",
        "_ -> _ -> _ -> _ -> {v:Map {v | key v = k; value v = v'} | mem k v' }",
        "_ -> _ -> _ -> _ -> _ -> _"
    ],
    "Ex10.hs--evalAny": [
        "_ -> _ -> Maybe _",
        "_ -> _ -> _ -> _",
        "{v:Expr | val v} ->  {v:Expr | Subset (free v) (keys G)}",
        "Map Var Expr -> {v:Expr | v}",
        "_ -> _ -> {v:Expr | v = e || v = plus (evalAny g e) (evalAny g e) }",
        "_ -> Expr -> _",
        "Env -> Expr -> Maybe Val",
        "Expr -> Maybe Expr",
        "_ -> _ -> Prop",
        "_ -> _ -> _",
        "Env -> ClosedExpr Env -> Maybe Val",
        "_ -> {v:Expr | val v}",
        "_ -> _ -> _ -> _ | _ -> {v:Expr | {v==null} || _ }",
        "Expr -> Bool",
        "Map k Expr ->  _ -> _ -> _",
        "Expr -> _",
        "_ -> _ -> _ | refl"
    ],
    "Ex10.hs--fresh": [
        "Int -> Expr",
        "Int -> Int",
        "{v:_ | false } -> v",
        "_ -> _",
        "[] -> _",
        "Int -> (Int, Int)",
        "Expr -> _",
        "_ -> Int",
        "{v:Set Var | v `Subset (keys g)} -> k",
        "[Int] -> Int"
    ],
    "Ex10.hs--lemNotElem": [
        "{v:a | v } -> {v:a | not v} -> _",
        "a -> [a] -> {v:Bool | not (Elem x v)}",
        "_ -> _ -> {v:Bool | false }",
        "_ -> _ -> _",
        "a -> [a] -> a -> Bool",
        "a -> [a] -> Bool",
        "a -> [a] -> {v:Bool | v }",
        "a -> [a] ->  {v:Bool | v }",
        "a -> [a] -> {v:Bool | v}",
        "a -> [a] -> TRUE",
        "a -> [a] -> _",
        "a -> [a] -> BOOL"
    ],
    "Ex11.hs--peekByteOff": [
        "p:Ptr a -> i:Nat -> v:{a | 0 < plen v}",
        "p:Ptr a -> off:Nat -> a",
        "Ptr a -> off:Nat -> IO a",
        "{v:ForeignPtr a | v == #0} -> len:Nat -> OkPtr a",
        "OkPtr a -> Nat -> IO a",
        "OkPtr a -> off:Nat -> IO a",
        "p:Ptr a -> n:Nat -> IO a",
        "p:Ptr a -> off:Nat -> v:{PtrN b {plen p - off} | 0 < plen v}",
        "a:Ptr {p:Void | 0 < plen a} -> off:Nat -> v:{PtrN b {plen p - off} | 0 < plen v}",
        "p:Ptr a -> i:{Nat | 0 <= i} -> v:Nat -> v:(PtrN a i)",
        "OkPtr a -> {v:Word8 | v ==? x}",
        "OkPtr a -> i:Nat -> v:{a | 0 <= i < plen v}",
        "Ptr a -> off:Nat -> v:{PtrN b {plen p - off} | 0 < plen v}",
        "{v:Ptr a | 0 < plen v} -> i:Nat -> IO a",
        "OkPtr a -> i:{Nat | 0 <= i} -> {v:a | 0 <= v}",
        "p:Ptr a -> n:Nat -> a",
        "a:Ptr -> off:Nat -> {v:Ptr a | v =? x}",
        "a:Ptr a -> o:Nat -> OkPtr b",
        "OkPtr a -> i:Nat -> IO a"
    ],
    "Ex11.hs--create'": [
        "n:Nat -> f:(Ptr a -> IO ()) -> ByteString2 B",
        "n:Nat -> {f:(Ptr Word8 -> IO a) | \\\\f = mallocForeignPtrBytes n}",
        "n:{Nat | 0 < n} -> {v:Nat -> IO ()} -> ByteStringN n",
        "n:Nat -> {v:a | 0 < n} -> ByteStringN n",
        "n:Nat -> {v:Ptr Word8 | 0 < plen v}",
        "n:Nat -> {v:ForeignPtr Word8 | 0 < plen v} -> ByteString",
        "n:{Nat | 0 < n} -> (Ptr Word8 -> IO ()) -> ByteString",
        "len:Nat -> {v:{PtrN a {plen v = len} | 0 < plen v} -> IO ()}",
        "n:{Nat | 0 < n} -> {v:() | v} -> ByteString",
        "n:Nat -> f:(Ptr Word8 -> IO ()) -> ByteString",
        "n:Nat -> f:Ptr Word8 -> ByteString",
        "n:Nat -> f:(Ptr Word8 -> IO ()) -> ByteStringN n",
        "n:Nat -> x:a -> IO a",
        "n:Nat -> (Ptr Word8 -> IO ()) -> ByteString",
        "n:Nat -> (Ptr a -> IO ()) -> ByteString",
        "n:Nat -> {v:ForeignPtrN a n | 0 < plen v} -> v:ByteString",
        "n:Nat -> {v:_ | v =/= 0} -> IO (ByteStringN n)",
        "n:Nat -> (ForeignPtrN a n -> IO a) -> ByteStringN n",
        "n:Nat -> IO (ForeignPtrN a n)"
    ],
    "Ex11.hs--pack": [
        "n:Nat -> {v:ByteString | fplen v = n}",
        "a -> String",
        "String: {v:_ | v = cs} -> {v:_ | isNullChar (last (splitCS (w2c cs)))}",
        "String -> ByteString2 B",
        "s:String -> ByteString",
        "xs:Word8 * -> {v:ByteString | 0 < fplen v}",
        "s:String -> s' {v:ByteString | bLen s' = len s'}",
        "String -> ByteString",
        "s:String -> {v:ByteString | bLen v = len s}",
        "{v:String | 0 < fplen v} -> ByteString",
        "Str -> ByteString",
        "ByteString -> String",
        "String -> {v:ByteString | bLen v = length v}",
        "{v:ByteString2 | bLen (fst v) = bLen v}",
        "{v:_ | v >= 0} -> String",
        "n:Nat -> String -> ByteStringN n"
    ],
    "Ex11.hs--unpack": [
        "ByteString2 B -> {v:String | 0 < len v}",
        "BS:ByteString2 -> String",
        "ByteStringN l -> {v:String | bLen v == l}",
        "BS -> String",
        "ByteString -> String",
        "ByteString -> {v:String | 0 <= fplen v}",
        "ByteStringN n -> String",
        "BS a -> {v:String | len v = bLen a}"
    ],
    "Ex11.hs--go''": [
        "Ptr Word8 -> Pos -> [W#] -> {v:ByteString | bOff v = s, len v = l}",
        "{v:Ptr Word8 | 0 <= plen v && plen v = fplen p} ->\n               {v:Int | 0 <= v && v < plen p} -> v:ByteString",
        "p:Ptr Word8 {v:_ | 0 <= plen v} -> n:Nat -> {v:Word8 | 0 <= v && v < 256} ->\n                {v:String | n < len v && v < fromEnum c} -> Bool {v:Bool | c <= v && v < fromEnum c}",
        "p:_ -> s:Nat | p `plusPtr` s < (p `plusPtr` ln)",
        "{v:Ptr Word8 | 0 < plen v} ->\n              v:Nat ->\n              acc:ListN Word8\n              -> TRUE",
        "OkPtr a -> Pos -> [Word8] -> [Word8] -> IO ()",
        "p:Ptr Word8 -> i:Nat -> acc:ListN Word8 {plen p}",
        "{v:Ptr Word8 | plen v = ln} ->\n                v:{v:Word8 | 0 < plen v} ->\n                acc:ListN {fplen :: Nat, l = wplen v} ->\n                {v:_ | 0 < plen v}",
        "p:Ptr Word8 | 0 < plen p | p /= 0 <-",
        "{v:Word8 | 0 < plen v} -> Pos -> ListN Word8 {plen p} -> ListN Word8 {plen p} -> ()",
        "p:{v:Ptr Word8 | 0 < plen v} -> {v:_ | bOff p + bLen p == s + ln} -> {v:_ | l == 0 || bOff p + bLen p <= s + ln} -> {v:_ | bOff p + bLen p >= s + ln} -> {v:Bool | 0 <= s + ln && bOff p + bLen p <= s + ln} -> {v:Bool | bOff p + bLen p <= s + ln}",
        "{v:Nat | v <= ln} -> (x:{Word8 | plen v = fplen x}, y:{Word8 | 0 < plen y}) -> { v2:_ | v2 = v + fplen x }",
        "p:Ptr Word8 -> len:{Int | 0 < len} -> acc:List Word8 {v:_ | len v =< len p} -> Bool",
        "p:Ptr Word8 -> i:{v:Nat | v < l} -> acc:ListN Word8 l -> IO ([Word8], ListN Word8 l)",
        "{v:Word8 | 0 <= v} -> n:Nat -> acc:ListN Word8 n | 0 < plen v} ->\n                p:Ptr Word8 -> LN -> acc:ListN Word8 n -> {v:String | 0 <= v && v < len acc}",
        "p:Ptr Word8 | len p =< l",
        "p:Ptr Word8 -> l:Nat -> acc:List String -> IO ()",
        "p:Ptr a -> i:{Pos | 0 <= i < fplen p} ->\n                      {v:Bool | (c2w (peekAt p i)) =",
        "s:Word8 -> n:Nat -> acc:{a | a /= null} ->\n                {v:{v:Word8 | v == null} | v == s}",
        "p:Ptr Word8 -> i:Nat -> acc:{v:Word8 | c2w v = c2w p} -> {v:_ | len acc == i}"
    ],
    "Ex11.hs--unsafeTake": [
        "n:Nat -> {v:ByteString | bOff v = fplen v && bLen v >= n}",
        "n:Nat -> {v:ByteString | 0 <= plen v && plen v = n}",
        "n:Nat -> ByteString -> OkPtr a",
        "n:Nat -> ByteString -> ByteString2 B",
        "n:{Nat | 0 <= n} -> B -> B",
        "l:Int -> ByteString -> ByteString",
        "n:Nat -> ByteString -> ByteStringN n",
        "n:Nat -> B -> OkPtr a",
        "n:Nat -> {v:ByteString | bLen v = n} -> ByteString",
        "n:Nat -> x:ByteString -> ByteString",
        "N:Nat -> ByteString -> ByteString",
        "n:{Nat | 0 <= n} -> ByteString -> ByteString",
        "{v:Nat | v < bLen b} -> b:{ByteString | bLen b = v} -> B:{ByteString2 b}",
        "n:Nat -> ByteString -> ByteString",
        "n:Nat -> bs:ByteString -> ByteStringN 1",
        "n:{Nat | n <= len p} -> p:Ptr a -> IO a",
        "N -> ByteString -> ByteString",
        "n:{Nat | 0 <= n} -> x:{ByteString | bLen x <= n} -> OkPtr a",
        "{v:Nat | v >= 0} -> OkPtr a -> IO a",
        "pos:Nat -> bs:{ByteString | bOff bs <= pos} -> bs"
    ],
    "Ex11.hs--unsafeDrop": [
        "m:Nat -> x:{ByteString | m <= bLen x} -> ByteStringN m",
        "Nat -> ByteString -> ByteString",
        "n:Nat -> ByteString -> ByteStringN (n-n)",
        "Int -> ByteString -> ByteString",
        "n:{Nat | 0 < n} -> ByteStringN -> ByteStringN",
        "n:Nat -> OkPtr a -> IO a",
        "i:Nat -> ByteStringN i",
        "n:Nat -> ByteString -> ByteString"
    ],
    "Ex11.hs--chop": [
        ":: String -> Nat -> String",
        "s:{String | 0 < len s} -> n:{Nat | 0 < len s} -> s",
        "s:{String | 0 < l} -> n:Nat -> String",
        "a:Char -> String -> {v:String | v = s | (c == v) && (n < l)}",
        "ByteString -> Nat -> ByteString",
        "ByteString -> Nat -> String",
        "{n:Int | n <= fplen bPtr} -> b:{ByteString | bLen b <= n} -> String",
        "s:String -> Int -> String",
        "ByteString -> Int -> String",
        "String -> Nat -> String",
        "ByteStringN n -> ByteStringN (n-m)",
        "s:String -> Nat -> String",
        "ByteStringN n -> String"
    ],
    "Ex11.hs--spanByte": [
        "Word8 -> ByteStringN 0",
        "c:{Char | 0 <= c} -> ByteString -> (ByteString, ByteString)",
        "c:Word8 -> {v:ByteString | bLen v = 0, c == bGet c}",
        "Word8 -> ByteString -> (ByteString, ByteString)",
        "c:Word8 -> ByteString -> (ByteString, ByteString)",
        "c:Word8 -> ByteString -> (ByteStringN (1+i) ByteString)",
        "{v:Bool | v} -> OkPtr Word8 -> (ByteString2 {v:ByteString | bLen v = 2} & OkPtr Word8) -> ByteStringN {v:Nat | v < bLen v} & OkPtr Word8",
        "{c:Word8 | False} -> ps:{ByteString | bLen ps >= 0} -> {xs:{Word8 | bLen xs >= 0}} -> {{xs,ys:ByteString | bLen xs = bLen ys}}",
        "c:Word8 -> BS -> (BS, BS)",
        "{v:ByteString | bLen v = 0} -> ByteString -> (ByteString, ByteString)",
        "w:Word8 -> ByteString -> (ByteString, ByteString)"
    ],
    "Ex12.hs--singleton": [
        "{t:AVL a | getHeight t > 0} -> {v:AVL a | getHeight v = 1}",
        "a -> AVL a",
        "a -> AVLN a 1",
        "a -> {v:AVL a | realHeight v > 0}",
        "{t:AVL a | getHeight t > 0} -> t"
    ],
    "Ex12.hs--mkNode": [
        "v:a -> L:{v:AVL a | realHeight L >= realHeight v}\n            -> R:{v:AVL a | realHeight R >= realHeight v}\n            -> {v:AVL a | realHeight v = realHeight L + realHeight R + 1}",
        "v: a -> l:{v: AVL a | getHeight l > 0} -> r:{v: AVL a | getHeight r > 0} -> AVL a",
        "{v:a | v > x} -> x:AVL a -> x:{v:AVL a | v > x} -> x:AVL a",
        "a ->  {v:AVL a | realHeight v = 0} -> {v:AVL a | realHeight v = 1} -> AVL a",
        "{v:a | v < X} -> {v:AVL a | v < X} -> {v:AVL a | X < v} -> AVL a",
        "a -> AVL a -> AVL a -> AVL a",
        "{v:a | v /= 0} -> {v': AVL a | v = v'} -> {v'': AVL a | v' = v''} -> AVL a",
        "{v: a | v > 0} -> {l: AVL a | isNode l} -> {r: AVL a | isNode r} -> AVL a",
        "a -> {v: AVL a | realHeight v >= 1} -> {v: AVL a | realHeight v >= 1} -> AVL a",
        "{v:a | v < X} -> AVL {v:AVL {v:a | v < X}}",
        "{v:a | realHeight v > 0} -> {v:AVL a | getHeight v > 0} -> {v:AVL a | getHeight v > 0} -> AVL a",
        "v:a -> l:AVLR a k -> r:AVLR a k -> AVLN a k",
        "{v:a | v > 0} -> l:{v: AVL a | isNode l} -> r:{v: AVL a | isNode r} -> {v: AVL a | isBal l v}",
        "a -> {v:AVL a | getHeight v = 0} -> {v:AVL a | getHeight v = 1} -> {v:AVL a | realHeight v = 1 + realHeight l v + realHeight r v} -> AVL a",
        "a -> l: {v:AVL a | getHeight l >= 1} -> r: {v:AVL a | getHeight r >= 1} -> AVL a",
        "{v:a | v < X} -> {vl: AVL a | v = nodeHeight vl l} -> {vr: AVL a | v = nodeHeight vr l} -> {v:AVL a | isReal (v =+ N)}"
    ],
    "Ex12.hs--getHeight": [
        "{t:AVL a | realHeight t > 0} -> _",
        "{v:AVL a | v > 0} -> {v:Nat | v < getHeight v}",
        "AVL a -> Int",
        "{t:AVL a | isNode t} -> {v: Int | v = realHeight t}",
        "{v:AVL a | realHeight v > 0} -> _",
        "{v:AVL a | isNode v} -> _",
        "{v:AVL a | getHeight v > 0} -> {n:_ | n >= 0}",
        "_ -> {v:Nat | isReal v l r}",
        "{v:AVL a | realHeight v >= 0} -> _",
        "{v:AVL a | v > 0} -> Int",
        "{v:AVL a | v > 0} -> _",
        "{t: AVL a | getHeight t > 0} -> _",
        "{v:AVL a | realHeight v > 0} -> {v:_ | v > 0}",
        "AVL a -> Nat",
        "{v:AVL a | getHeight v > 0} -> _",
        "{v:AVL a | getHeight v > 0} -> Nat"
    ],
    "Ex12.hs--balL0": [
        "a -> a -> AVL a",
        "{v:a | v == 0} -> AVL {v:a | v > 0}",
        "a -> AVL a -> AVL a -> AVL a",
        "a -> {v: AVL a | realHeight v > 0} -> {v: AVL a | false}",
        "{t:AVL a | getHeight t > 0} -> AVL a -> AVL a -> AVL a",
        "{v:AVL a | v == 0} -> {v:AVL a | v > 0} -> {v:AVL a | v < 0} -> {v:AVL a | false}",
        "{v:AVL a | v < 0} -> AVL a",
        "_ -> _ -> {t:AVL a | t == 0}",
        "{t:AVL a | getHeight t > 0} -> _",
        "a -> {v:AVL a | v == 0}",
        "{v:AVL a | isBal (leaf) v 0} -> _"
    ],
    "Ex12.hs--balLL": [
        "a -> AVL a -> AVL a -> AVL a"
    ],
    "Ex12.hs--balLR": [
        "{v:a | getHeight v > 0} -> {v:AVL a | getHeight v > 0} -> {v:AVL a | getHeight v > 0} -> {v:AVL a | isBal v l r}",
        "{v:a | X < v} -> a",
        "{v:a | isBal l v 1} -> _",
        "{t:AVL a | isBal l t 1} -> _",
        "v:AVL a -> {v':AVL a | v' == v} -> {v:AVL a | v == v'} -> {v:AVL a | v == v'}",
        "{v:AVLR a key | isBal l v 1} -> AVLR a key",
        "a -> AVL a -> AVL a -> AVL a",
        "{v:a | isReal v l r} -> v",
        "{v:a | false} -> _"
    ],
    "Ex12.hs--balR0": [
        "{v:a | X < v} -> {v:AVL a | v < X}",
        "{v:a | isBal v (Node Empty v Empty 0) 1} -> AVL a",
        "a -> AVL a -> AVL a -> AVL a\nbalR0 v l (Node rv rl (Node rrv rll rlr _) _) = mkNode rv (mkNode v l rl) (mkNode rrv rll rlr)\n\n{-@ balLL :: a -> AVL a -> AVL a -> AVL a\nbalLL v l r = mkNode v l (mkNode v r r)\n\nbalLR :: a -> AVL a -> AVL a -> AVL a\nbalLR v l r = mkNode v l (mkNode v r r)",
        "a -> AVL a -> AVL a -> AVL a",
        "{v:a | false} -> _",
        "a -> AVL a -> AVL a -> AVL a\nbalR0 :: a -> AVL a -> AVL a -> AVL a\nbalR0 v l (Node (Node (Node rv (Node lrv lrl lrr _) _) _) rr _) = mkNode rv (mkNode lrv lrl lrr) rr\n\nbalR0 :: a -> AVL a -> AVL a -> AVL a\nbalR0 v l (Node rv rl rr _) = mkNode rv (mkNode v l rl) rr\n\nbalR0 :: a -> AVL a -> A",
        "{a:_ | x:AVL a | x == 0} -> AVL {v:a | v == 0}",
        "a -> AVL a -> AVL a -> AVL a\nbalR0 :: a -> AVL a -> AVL a -> AVL a\nbalR0 :: a -> AVL a -> AVL a -> AVL a\nbalR0 :: a -> AVL a -> AVL a -> AVL a\nbalR0 :: a -> AVL a -> AVL a -> AVL a\nbalR0 :: a -> AVL a -> AVL a -> AVL a\nbalR0 :: a -> AVL a -> AVL a -> AVL a\nbalR0 :: a ->"
    ],
    "Ex12.hs--balRR": [
        "a -> AVL a -> AVL a -> AVL a"
    ],
    "Ex12.hs--balRL": [
        "a -> AVL a -> AVL a -> AVL a\nbalRL v l r = mkNode v (mkNode v l r) r",
        "a -> AVL a -> AVL a -> AVL a"
    ],
    "Ex12.hs--bal": [
        "{v:AVL a | realHeight v > 0} -> 0 -> {v1:AVL a | realHeight v1 > 1}",
        "v:AVL a -> l:AVL a -> r:AVL a -> AVL a",
        "v:AVL a -> l:AVLN a m -> r:AVLR a n -> AVL a",
        "v:AVLN a {getHeight v}  -> _",
        "v:a -> {v:AVL a | realHeight v >= 0 && realHeight v > 0}",
        "a -> AVL a -> AVL a -> AVL a",
        "a -> a -> a -> {t:AVL a | v > x && v < y}",
        "a -> {v:AVL a | isBal l v 1}\n    | lBig = balL0 v l r\n    | lBig = balLL v l r\n    | lBig = balLR v l r\n    | lBig = balL0 v l r\n    | lBig = balLL v l r\n    | lBig = balLR v l r\n    | otherwise = {v:AVL a | false}",
        "{l: AVL a | isNode l} -> {r: AVL a | isNode r} -> _",
        "a -> {v:AVL a | isBal v 0 1}",
        "a -> {v:AVL a | v /= 0} -> {v:AVL a | v /= 0} -> {v:AVL a | v /= 0}",
        "{v:AVL a | v > 0} -> v:AVL a",
        "v:AVL a -> {l:AVL a | isNode l} -> {r:AVL a | isNode r} -> AVL a"
    ],
    "Ex12.hs--insert": [
        "{v:a | v < x} -> t:AVL a -> AVL a",
        "{v:a | v < v'} -> x -> AVLN a 0",
        "{a: AVL a | isNode a} -> {a: AVL a | isNode a}",
        "a: {v:String | false} -> e:AVL a -> EQ a e e e",
        "(Ord a) => a -> AVL a -> AVL a",
        "{a:_ | _ < a} -> x:AVL a | _ <= x} -> {y:AVL a | _ > x} -> y",
        "a:a -> l:AVL a -> (t:AVL a | getHeight t == getHeight l)",
        "{v:a | v < getHeight t} -> t:AVL a -> AVL a",
        "{v:a | v < key t} -> t -> t",
        "{v: String | v == \"no insertion\"}  -> _",
        "Ord a => a -> AVL a -> AVL a",
        "{v: a | v < _} -> l: {v: AVL a | getHeight l > 0} -> r: {v: AVL a | getHeight r > 0} -> _",
        "{v:a | v < y} -> {t:AVL a | isNode t} -> {t':AVL a | isNode t'}",
        "a:_ -> {v: AVL a | getHeight v > 0} -> AVL a",
        "(Ord a) => x:a -> {v:AVL a | v < x}"
    ],
    "Ex12.hs--delete": [
        "{v:String | false} -> {v:AVL a | false} -> {v:AVL a | false}",
        "{v:AVL a | v == y} -> AVL a",
        "a -> AVL a -> AVL a",
        "(Ord a) => a -> AVL a -> AVL a",
        "{y:a | y > x} -> {v:AVL a | isNode v} -> {t:AVL a | isNode t}",
        "{v:String | false} -> {v' : AVL a | false}",
        "{y: a | y /= x && isNode y} ->  AVL a",
        "{v:String | false} -> a -> {t:AVL a | v == key t}",
        "{x: String | false} -> AVL a -> AVL a",
        "Ord a => a -> AVL a -> AVL a",
        "{v: AVL a | getHeight v == 0} -> AVL a",
        "{t: AVL a | isNode t} -> a -> _",
        "{x:a | x < y} -> {v:AVL a | x == y || eqOrDn v y}",
        "{v:a | v == y} -> AVL a -> AVL a",
        "Ord a => a -> {v:AVL a | true}",
        "{v:String | v == \"impossilbe for Leaf\"} -> a",
        "{v:AVL a | v == y} -> AVL a -> AVL a"
    ],
    "Ex12.hs--merge": [
        "{x:a | x < y} -> (x, r) -> (y', r')",
        "{x:a | 0 <= x <= y} -> {v:AVL a | x < y} -> {u:AVL a | y < v}",
        "_ -> _ -> _",
        "a -> AVL a -> AVL a -> AVL a",
        "a -> AVL a -> AVL a -> {v:AVL a | eqOrDn v t}",
        "a -> _ -> _ -> AVL {v:AVL a | v == x || v == y}",
        "a -> AVL a -> AVL a -> _",
        "a -> {v:AVL a | v < r} -> {v:AVL a | v <= r} -> {v:AVL a | v > r}",
        "{y: a | isNode y} -> {v: AVL a | isNode v && v == y }",
        "{v:AVL a | v == x} -> {v:AVL a | v == y} -> {v:AVL a | v /= y} -> AVL a",
        "{y:{v:a | v < x} | v == y} -> {v:AVL a | eqOrDn v y} -> {v:AVL a | eqOrDn v x}",
        "a -> AVL a -> AVL a -> {t:AVL a | eqOrDn t l v }",
        "a -> {v:AVL a | isBal y v 1 && eqOrDn y v} -> {v:AVL a | isBal y v 0 && eqOrDn y v}",
        "a -> {v:AVL a | isReal v l r || v < x || x < v}"
    ],
    "Ex9.hs--cons": [
        "x:a -> xs:SList a -> {v:SList a | size v = {n:Nat | n > 0 && x < elems v}}",
        "a -> SList a -> SList a",
        "{v:a | v = _} -> {v:SList a | realSize v = _}",
        "a -> {v:SList a | size v = {v:Nat | v >= 1} } -> SList a",
        "{v:a | true} -> {v:a | true} -> SList a",
        "x:a -> {v:SList a | size v = 1 + size v}",
        "x:a -> xs:_ -> {v:SList a | size v = size xs + 1}",
        "a -> {v:SList a | realSize v = size xs + 1} -> SList a",
        "a -> {v:SList a | realSize v = size xs} -> {v:SList a | realSize v = size ys}",
        "a -> {v:SList a | realSize v = size s} -> {v:SList a | realSize v = size t}"
    ],
    "Ex9.hs--hd": [
        "SList a -> {v:a | size v = 0}",
        "{v:a | realSize v > 0}",
        "SListN a N -> a",
        "{v:a | v == (hd :: {v:SList a | size v = 0}) }",
        "SList a -> a",
        "SListLE a N -> a",
        "SListLE a 0",
        "SListN a _",
        "SListN a 1",
        "{v:a | v = x}",
        "{v:_ | true} -> a",
        "SListN a N",
        "SListN a 0 -> a"
    ],
    "Ex9.hs--tl": [
        "{v:SList a | size v > 0} -> {v:SList a | size v > 0}",
        "SList a -> {v:_ | false}",
        "SList a -> {v:SList a | size v = 1}",
        "SList a -> {v:SList a | size v > 0}",
        "SList a -> SList a"
    ],
    "Ex9.hs--rot": [
        "{v1:[a] | v1 < v2} -> {v2:[a] | v1 =< v2} -> {v3:[a] | v1 = v2} -> {v4:[a] | v3 < v4} -> {v5:[a] | v4 = v3} -> SList a",
        "SList a -> SList a -> SList a -> SList a",
        "{f:[a] | size f > 0} -> {b:[a] | size b > 0} -> {a:[a] | realSize b = realSize f}",
        "{v:SList a | size v = _ } -> {v:SList a | size v = _ } -> {v:SList a | size v = _ } -> {v:SList a | size v = _ }",
        "{v:SList a | size v > 0} -> {v:SList a | size v > 0} -> {v:SList a | size v > 0} -> {v:SList a | size v > 0}",
        "SList a -> SList a -> SList a -> {v:SList a | qsize v = qsize f + qsize b + qsize a}",
        "{v:SList a | false} -> {v1:SList a | false} -> {v2:SList a | false} -> SList a",
        "{v:SList a | size v > 0} -> {v:SList a | size v > 0} -> {v:SList a | size v > 0} -> {v:SList a | true}"
    ],
    "Ex9.hs--makeq": [
        "{v:SList a | realSize v = 2} -> {v:SList a | realSize v = 2}",
        "{v:SList a | realSize v = 1} -> {v:SList a | realSize v = 1} -> Queue a",
        "{v:_ | false} -> a -> a -> Queue a",
        "SListN _ 0",
        "{v:_ | size v = 2}",
        "f:SListN a 0 -> b:SList a -> {v:Queue a | qsize v = 0}",
        "SList a -> SList a -> {v:Queue a | qsize v = 0}",
        "{v:SList a | v == []} -> {v:SList a | v == [] || v == [] || v == []}",
        "{v:SList a | true} -> {v1:SList a | true} -> Queue a",
        "SList a -> SList a -> Queue a",
        "SListN a 0"
    ],
    "Ex9.hs--remove": [
        "QueueN _ 2",
        "Queue a -> {v:a | true}",
        "{v:SList a | qsize v > 0} -> Queue a",
        "(QueueN a 0, QueueN a 0) -> (a, Queue a)",
        "(a, Queue a) -> Queue a",
        "QueueN a N -> (a, QueueN a N)",
        "{v:SList a | v /= nil} -> Queue a",
        "{v:_ | false} -> {v:_ | false}",
        "a -> Queue a -> Queue a",
        "(a, Queue a)",
        "QueueN _ 1",
        "{v:String | false} -> SList a",
        "Queue a -> (a, Queue a)",
        "{v:_ | false} -> QueueN a 0"
    ],
    "Ex9.hs--insert": [
        "a -> QueueN a _ -> QueueN a _",
        "a -> QueueN a {+ 1}",
        "{v:a | v > 0} -> Queue a -> Queue a",
        "a -> QueueN a 1",
        "a -> QueueN a N -> QueueN a (N+1)",
        "a -> Queue a -> {v:Queue a | qsize v > 0}",
        "a -> Queue a -> Queue a",
        "a -> {v:Queue a | (back v) /= nil}",
        "a -> {v:Queue a | v = insert e v}",
        "a -> QueueN _ 2"
    ],
    "Ex9.hs--take": [
        "Nat -> SListN a _ -> {v:SList a | size v = n}",
        "Int -> (QueueN a 0, QueueN a (size (f take 0)))",
        "{v:_ | realSize v > 0} -> x:_ -> QueueN x (_ > 0)",
        "{n:Int | 0 <= n} -> Queue a -> (Queue a, Queue a)",
        "Int -> QueueN a 0 -> (QueueN a 1, QueueN a 0)",
        "{v:SList a | realSize v >= n} -> QueueN a n -> (QueueN a 0, QueueN a n)",
        "Nat -> QueueN a N -> (QueueN a N, QueueN a 0)",
        "Nat -> {v:Queue a | qsize v = Nat}",
        "{v:_ | v >= 0} -> N -> {v:SList a | v = size v}",
        "Int -> {v: QueueN a n | qsize v = n}",
        "Nat -> Queue a -> (Queue a, Queue a)",
        "Int -> QueueN a 0 -> (Queue a, Queue a)",
        "{n:{v:Int | v <= n} | n > 0 } -> QueueN a n",
        "Int -> SListLE a N -> (SList a, SListLE a N)",
        "Int -> QueueN a 0 -> (QueueN a n, QueueN a (n-1))",
        "{n:Int | n >= 0} -> SListLE a n -> (SList a, SListLE a (n-1))}",
        "{v:String | true} -> Queue a -> (String, Queue a)",
        "Int -> Queue a -> (Queue a, Queue a)"
    ]
}